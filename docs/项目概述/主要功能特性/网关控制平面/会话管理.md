# 会话管理

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构总览](#架构总览)
5. [详细组件分析](#详细组件分析)
6. [依赖关系分析](#依赖关系分析)
7. [性能考量](#性能考量)
8. [故障排查指南](#故障排查指南)
9. [结论](#结论)
10. [附录](#附录)

## 简介
本文件系统性阐述 OpenClaw 的会话管理系统，覆盖会话标识符生成、会话状态维护、会话生命周期管理、会话隔离机制、会话键解析、会话查询、会话清理与迁移策略，并扩展到多代理会话管理、会话持久化、冲突解决与会话恢复。同时提供面向开发者的性能优化、内存管理与并发访问控制的技术建议。

## 项目结构
OpenClaw 将会话管理拆分为“概念文档”“配置与存储层”“运行时初始化与状态维护”“工具与查询”“迁移与兼容”等多个层次，确保“网关为源”“状态可追踪、可恢复、可迁移”。

```mermaid
graph TB
subgraph "概念与参考"
DOC1["会话概念<br/>session.md"]
DOC2["会话修剪<br/>session-pruning.md"]
DOC3["会话与压缩深度<br/>session-management-compaction.md"]
end
subgraph "配置与存储"
CFG["sessions.ts<br/>导出会话相关模块"]
KEYUTIL["session-key-utils.ts<br/>键解析与父会话推导"]
SLUG["session-slug.ts<br/>会话标识符生成"]
MIG["state-migrations.ts<br/>旧态迁移与规范化"]
end
subgraph "运行时"
INIT["session.ts<br/>会话初始化与状态维护"]
HELP["sessions-helpers.ts<br/>会话引用解析与分类"]
STATUS["session-status-tool.ts<br/>会话状态查询与模型覆盖"]
end
DOC1 --> CFG
CFG --> INIT
CFG --> HELP
CFG --> STATUS
KEYUTIL --> INIT
KEYUTIL --> STATUS
SLUG --> INIT
MIG --> CFG
MIG --> INIT
HELP --> STATUS
```

## 核心组件
- 会话键解析与父会话推导：用于识别会话类型、解析主会话别名、判断线程/话题会话并推导父会话键。
- 会话标识符生成：生成短语化 slug 作为会话 ID 基础，避免冲突并具备可读性。
- 会话状态维护：在每次入站消息时评估新鲜度、决定是否重置、合并元数据、更新存储与转录。
- 会话查询与跨代理访问：支持按键或 sessionId 解析，遵循 A2A 策略，提供状态卡片与用量信息。
- 会话生命周期与重置策略：基于每日/空闲/类型/通道级重置策略，支持触发式重置。
- 会话持久化与迁移：两层持久化（sessions.json 与 *.jsonl），旧态迁移与键规范化。
- 会话修剪与压缩：运行前修剪工具结果以降低上下文膨胀；压缩持久化摘要以减少历史体积。

## 架构总览
下图展示从入站消息到会话状态落盘的关键流程，以及跨代理访问与状态查询的交互。

```mermaid
sequenceDiagram
participant In as "入站消息"
participant Init as "会话初始化<br/>initSessionState"
participant Store as "会话存储<br/>sessions.json"
participant Trans as "会话转录<br/>*.jsonl"
participant Tool as "会话状态工具<br/>session_status"
participant GW as "网关"
In->>Init : "解析会话键/组键/线程标志"
Init->>Init : "评估重置策略/新鲜度"
alt 需要重置
Init->>Init : "生成新 sessionId"
end
Init->>Store : "写入/合并 SessionEntry"
Init->>Trans : "确保 sessionFile 存在"
Init-->>In : "返回模板上下文与状态"
Tool->>GW : "sessions.resolve(键/ID)"
GW-->>Tool : "返回标准化键"
Tool->>Store : "读取并格式化状态"
Tool-->>Tool : "可选设置模型覆盖"
Tool-->>In : "返回状态卡片"
```

## 详细组件分析

### 会话键解析与父会话推导
- 功能要点
  - 解析 `agent:*` 类型键，提取 agentId 与剩余部分。
  - 判断子代理键与 ACP 键。
  - 从线程/话题标记推导父会话键，支持多通道/多账户场景。
- 关键路径
  - `parseAgentSessionKey`
  - `isSubagentSessionKey`
  - `isAcpSessionKey`
  - `resolveThreadParentSessionKey`

```mermaid
flowchart TD
A["输入 sessionKey"] --> B{"是否为空/无效?"}
B --> |是| Z["返回 null"]
B --> |否| C["按 ':' 分割并过滤空白"]
C --> D{"长度 < 3 或首段非 'agent'?"}
D --> |是| Z
D --> |否| E["提取 agentId 与 rest"]
E --> F{"rest 是否以 'subagent:' 或 'acp:' 开头?"}
F --> |是| G["判定类型并返回"]
F --> |否| H{"包含 ':thread:' 或 ':topic:' ?"}
H --> |是| I["取该标记之前的前缀作为父键"]
H --> |否| J["返回 null 或保留原键"]
```

### 会话标识符生成
- 功能要点
  - 使用形容词+名词组合生成 slug，优先尝试 2/3 词组合，失败后带随机后缀回退。
  - 支持 isTaken 回调避免冲突，适用于不同命名空间（如进程会话、会话键）。
- 关键路径
  - `createSessionSlug`

```mermaid
flowchart TD
S["开始"] --> R["生成候选: 2/3 词组合"]
R --> T{"isTaken(候选) ?"}
T --> |否| U["返回候选"]
T --> |是| V["尝试候选-2..-12"]
V --> W{"存在未占用?"}
W --> |是| U
W --> |否| X["生成 3 词+随机后缀"]
X --> Y{"isTaken(回退) ?"}
Y --> |是| Z["追加时间戳后缀"]
Y --> |否| U
```

### 会话状态维护与生命周期
- 功能要点
  - 基于会话作用域与入站上下文解析会话键，支持主会话别名与组键。
  - 评估重置策略（每日/空闲/类型/通道），必要时生成新 sessionId 并重置压缩计数。
  - 合并/保留历史状态字段（思考级别、队列策略、令牌统计、模型覆盖等）。
  - 维护父会话分支与转录文件路径，确保线程/话题隔离。
- 关键路径
  - `initSessionState`

```mermaid
flowchart TD
A["入站消息"] --> B["解析会话键/组键/线程标志"]
B --> C["计算重置类型/通道重置策略"]
C --> D{"fresh? (依据 updatedAt 与策略)"}
D --> |是| E["复用 sessionId 与历史状态"]
D --> |否| F["生成新 sessionId 并重置压缩计数"]
E --> G["合并元数据/路由/模型覆盖"]
F --> G
G --> H["写入 sessions.json 并确保 sessionFile"]
H --> I["返回模板上下文与状态"]
```

### 会话查询与跨代理访问控制
- 功能要点
  - 支持按键或 sessionId 查询，自动补全默认 agent 前缀与 main 别名。
  - 跨代理访问通过 tools.agentToAgent 策略控制，拒绝未授权访问。
  - 提供状态卡片，包含用量、时间、队列、模型认证标签等。
  - 可选设置 per-session 模型覆盖，变更后原子更新存储。
- 关键路径
  - `resolveSessionEntry`
  - `resolveSessionKeyFromSessionId`
  - `createAgentToAgentPolicy`
  - `resolveSessionReference`

```mermaid
sequenceDiagram
participant Caller as "调用者"
participant Tool as "session_status 工具"
participant Helper as "sessions-helpers"
participant GW as "网关"
participant Store as "sessions.json"
Caller->>Tool : "传入 sessionKey 或 sessionId"
Tool->>Helper : "resolveSessionEntry/resolveSessionReference"
alt sessionId
Tool->>GW : "sessions.resolve(sessionId)"
GW-->>Tool : "返回标准化键"
end
Tool->>Store : "读取 SessionEntry"
Tool-->>Caller : "返回状态卡片/可选更新模型覆盖"
```

### 会话隔离与多代理管理
- 功能要点
  - 会话键以 `agent:*` 形式隔离不同代理；支持 `subagent:*` 与 `acp:*` 特殊键。
  - 主会话别名与 scope 控制主键行为；identityLinks 支持跨通道同一人的会话共享。
  - 跨代理访问需满足 tools.agentToAgent.enabled 与 allow 规则。
- 关键路径
  - `createAgentToAgentPolicy`

### 会话持久化与清理
- 功能要点
  - 两层持久化：sessions.json（小而快，记录当前 sessionId 与元数据）、*.jsonl（树形转录，记录对话与压缩摘要）。
  - 清理策略：删除 sessions.json 条目或移除 *.jsonl 即可重建；建议按键粒度清理以保留其他上下文。
  - 运行前修剪工具结果，不改写 *.jsonl；压缩为持久摘要，减少历史体积。

### 会话迁移与冲突解决
- 功能要点
  - 自动检测旧态目录与 sessions.json，规范化键、合并条目、迁移文件。
  - 旧键与新键冲突时，按 updatedAt 与优先级合并，保留最新有效数据。
  - 支持主会话迁移与 WhatsApp 认证目录迁移。
- 关键路径
  - `detectLegacyStateMigrations`
  - `canonicalizeSessionStore`
  - `mergeSessionEntry`

```mermaid
flowchart TD
A["检测旧态"] --> B["读取 legacy/target store"]
B --> C["canonicalizeSessionStore 规范化键"]
C --> D["mergeSessionEntry 冲突解决"]
D --> E["保存至 target sessions.json"]
E --> F["迁移/重命名相关文件"]
```

### 会话恢复机制
- 功能要点
  - 通过 sessions.resolve 在网关侧解析 sessionId/键，保证跨沙箱可见性与一致性。
  - 会话初始化时根据重置策略决定是否复用 sessionId，否则生成新 ID 并重置压缩计数。
  - 父会话存在时可分叉生成新的转录文件，保持树形结构与上下文连续。
- 关键路径
  - `resolveSessionReference`
  - `initSessionState`

## 依赖关系分析
- 组件耦合
  - 会话初始化依赖配置与存储模块，受会话键解析与线程标志影响。
  - 会话状态工具依赖网关解析与存储读取，受 A2A 策略约束。
  - 迁移模块独立于运行时，仅在启动阶段扫描与规范化旧态。
- 外部依赖
  - 转录管理由 @mariozechner/pi-coding-agent 的 SessionManager 负责，OpenClaw 通过其接口读写 *.jsonl。
- 潜在循环
  - 无直接循环依赖；工具与运行时通过网关接口解耦。

```mermaid
graph LR
INIT["initSessionState"] --> CFG["sessions.ts 导出模块"]
INIT --> KEY["session-key-utils"]
INIT --> PRUNE["session-pruning"]
INIT --> COMP["session-management-compaction"]
TOOL["session_status"] --> HELP["sessions-helpers"]
TOOL --> CFG
TOOL --> GW["网关解析"]
MIG["state-migrations"] --> CFG
MIG --> INIT
```

## 性能考量
- 会话修剪（session-pruning）
  - 仅对工具结果进行软修剪/硬清除，保护用户与助手消息；针对超大工具输出提升首次请求缓存效率。
  - TTL-aware 模式与心跳配合，避免过期缓存导致重复缓存开销。
- 压缩与内存刷新
  - 预压缩内存刷新（Pre-compaction Memory Flush）在接近阈值时执行静默写盘，减少压缩后丢失关键上下文的风险。
  - reserveTokens 安全地板保障多轮“家务活”（如写内存）有足够头寸。
- 存储与 IO
  - sessions.json 小而快，适合频繁读写；转录 *.jsonl 采用树形结构，压缩后仅保留摘要，降低磁盘占用。
- 并发与锁
  - 会话写入采用原子更新（先内存合并再落盘），避免竞态；跨代理访问通过网关统一解析，减少本地文件竞争。

## 故障排查指南
- 会话键错误
  - 使用 /status 或 openclaw status 确认 sessionKey 与主会话别名；检查 identityLinks 与通道映射。
- 存储与转录不一致
  - 确认网关主机与 store 路径；远程模式下不要只查本地文件。
- 重置异常
  - 检查 resetTriggers、resetByType、resetByChannel 与 daily/idle 策略；确认命令授权与大小写匹配。
- 跨代理访问被拒
  - 检查 tools.agentToAgent.enabled 与 allow 规则；确保请求者与目标代理均满足白名单。
- 会话修剪无效
  - 确认使用的是 Anthropic API 且 cache-ttl 模式启用；调整 TTL 与工具白名单。
- 压缩过于频繁
  - 调整 reserveTokens 与 keepRecentTokens；减少工具结果体量或开启修剪。

## 结论
OpenClaw 的会话管理以“网关为源、键驱动隔离、双层持久化、运行前修剪、预压缩刷新”为核心设计，既保证了多代理与多通道下的会话一致性与可恢复性，又兼顾了性能与可观测性。通过规范化的键解析、严格的跨代理访问策略与完善的迁移机制，系统在复杂场景中仍能保持稳定与可维护性。

## 附录
- 会话创建（伪代码路径）
  - `initSessionState`
- 会话状态查询（伪代码路径）
  - `createSessionStatusTool`
- 会话销毁（伪代码路径）
  - 删除 sessions.json 中对应键或移除 *.jsonl 文件；下一次入站消息将重建。
- 会话迁移（伪代码路径）
  - `detectLegacyStateMigrations`
  - `migrateLegacySessions`